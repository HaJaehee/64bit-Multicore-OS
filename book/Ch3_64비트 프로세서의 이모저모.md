# 64비트 프로세서의 이모저모

## Index
 - 운영모드
 - 운영모드와 레지스터
 - 운영모드와 메모리 관리기법

## 운영모드
인텔 64비트 호환 프로세서(이하 x86-64 프로세서)에서는 크게 다섯가지 운영모드가 있다.
우리에게 친숙한 16비트의 리얼 모드, 32비트 보호 모드, 64비트의 IA-32e 모드, 시스템 관리 모드, 가상 8086 모드가 있다.
각 모드는 컨트롤 레지스터와 인터럽트라는 특수한 이벤트를 통해 각 모드로 전환할 수 있다.

| 운영 모드 | 설명 |
| :-------: | :--- |
| 리얼 모드 | 프로세서의 초기 상태로서 16비트 모드로 동작<br/>최대 1MB의 주소 공간 지원 |
| 보호 모드 | 32비트 모드로 동작하며 세그먼트, 페이징, 보호, 멀티태스킹 등의 기능 제공<br/>4GB 주소 공간 지원 |
| IA-32e 모드 | 32비트 호환 모드와 64비트 모드의 두 가지 서브모드로 구성<br/>16EB의 주소 공간 지원 |
| 시스템 관리 모드 | 전원 관리나 하드웨어 제어 같은 특수 가능을 제공하는 모드 |
| 가상 8086 모드 | 보호 모드 내부에서 가상의 환경을 설정하여 리얼 모드처럼 동작하는 모드 |

x86-64 프로세서는 위와 같이 총 다섯 가지 운영 모드 지원하지만, 위 운영 모드를 모두 구현해야 OS를 개발할 수 있는건 아니다.
64 비트 OS가 반드시 지원해야 하는 모드는 **리얼모드**, **보호 모드**, **IA-32e모드 중 64비트 서브모드**이다.
나머지 다른 모드는 특수한 상황에서만 사용되므로 반드시 구현할 필요는 없다.

### 리얼 모드
프로세서가 전원이 켜지거나 리셋되면 가장 먼저 리얼모드로 진입한다.
리얼모드는 과거의 16비트 프로세서와 동일하게 동작하며, 이후에 설명할 BIOS(Basic Input Output System)의 여러 기능을 사용할 수 있다.
리얼 모드는 디바이스 드라이버를 제작하지 않아도 되는 장점이 있고, 하는 작업도 OS 이미지를 디스크에서 메모리로 복사하여 보호 모드로 변경하는 것 밖에 없지만, 대부분 작업을 어셈블리어로 처리해야 한다는 단점이 있다.

### 보호 모드
보호 모드는 IA-32e 모드로 전환하려면 공식적으로 거쳐야 하는 모드로, 32비트 윈도우나 리눅스 OS가 동작하는 기본 모드입니다.
최대 4GB의 주소 공간을 제공하며 OS의 필수 기능으로 자리 잡은 보호, 멀티태스킹, 세그먼테이션, 페이징 등의 기능을 하드웨어적으로 지원한다.
여러 기능을 제공하는 만큼 복잡하고, 레지스터와 자료구조가 다양하다.

### IA-32e 모드
IA-32e 모드에는 서브모드로 32비트 호환 모드와 64비트 모드가 있다.
32비트 호환 모드는 보호 모드와 같은 기능을 수행하므로 64비트 모드를 위주로 살펴보겠다.
IA-32e 모드는 최대 16EBd의 주소 공간을 제공하며 레지스터 수도 보호 모드보다 많다.
다만 자료 구조는 더 복잡하지 않고 대부분 보호 모드와 같거나 크지만 2배로 확장되고 일부 필드의 의미가 변하는 정도이므로 보호 모드와 큰 차이는 없다.
한가지 재미있는 사실은 프로세서가 32비트 호환 모드일 때는 보호모드에 있는 것처럼 동작하므로 32비트 코드를 그대로 실행할 수 있다는 점이다.
64비트 OS에서 32비트 보호 모드 코드를 별다른 처리 없이 그대로 실행할 수 있는 것도 이러한 서브모드를 사용하기 때문이다.

### 운영 모드 사이의 관계와 운영 모드의 전환
특정 모드에서 다른 모드로 전환하는 작업은 현재 동작 중인 모드에 따라 차이가 있다.
리얼 모드에서 보호 모드로 전환하는 상황처럼 다른 모드를 거치지 않고 바로 전환 가능한 경우도 있지만 리얼모드에서 IA-32e모드로 전환하는 상황과 같이 리얼모드 -> 보호모드 -> IA-32 모드를 거쳐서 전환해야 하는 경우도 있다.

![](https://github.com/HIPERCUBE/64bit-Multicore-OS/blob/master/book/img/Ch3_img1.png)

위 그림의 화살표 위에 표시된 내용은 해당 모드로 전환하는데 필요한 조건을 나타낸 것이다.
조건에는 컨트롤 레지스터와 인터럽트 발생만 표시되어 있지만, 기본적으로 각 모드에 필요한 자료구조는 미리 설정되어 있어야 한다.
화살표가 연결되지 않은 리얼모드에서 IA-32e 모드로 전환하는 것은 불가능하며, 무리하게 시도하면 리셋이나 예외가 발생할 수 있다.
(실제 편법을 사용하면 가능하긴 하지만 여기서는 다루지 않는다.)


## 운영 모드와 레지스터
OS를 개발하는 관점에서 운용 모드는 크게 16비트 모드, 32비트 모드, 64비트 모드 세 가지로 나눌 수 있다.
운영 모드 앞에 붙은 숫자는 레지스터의 크기와 관계가 있으며 숫자가 커질수록 레지스터의 개수도 많아진다.

![](https://github.com/HIPERCUBE/64bit-Multicore-OS/blob/master/book/img/Ch3_img2.png)

보호모드에서의 레지스터


![](https://github.com/HIPERCUBE/64bit-Multicore-OS/blob/master/book/img/Ch3_img3.png)

IA-32e모드에서의 레지스터


x86-64 프로세서에는 위 그림들과 같이 많은 레지스터가 있지만, OS를 개발하는 과정에서 큰 비중을 차지하는 **범용 레지스터**, **세그먼트 레지스터**, **컨트롤 레지스터** 세 가지이다.

### 범용 레지스터
범용 레지스터(General Purpose Register)는 운영 모드와 가장 관계가 깊은 레지스터이다.
범용 레지스터는 계산, 메모리 어드레스 지정, 임시 저장 공간 등의 목적으로 사용한다.
범용 레지스터 수는 프로세서가 지원하는 운영 모드에 따라 다르다.
16비트와 32비트 모드를 지원하는 x86 계열은 8개, 64비트 모드를 지원하는 x86-64 계열은 16개의 범용 레지스터가 있다.

범용 레지스터 수가 늘어나면 메모리에 접근하는 시간을 줄임으로서 수행 속도가 개선될 수 있다는 장점이 있다.
이와 비슷한 효과는 함수 호출에도 그대로 적용된다.
다수의 범용 레지스터에 함수 파라미터를 넣어 넘겨줌으로서 스택 영역의 메모리에 접근하는 시간과 스택을 정리하는 시간을 줄일 수 있다.

이름에서 알 수 있듯이 범용 레지스터의 용도는 고정된 것이 아니며, 다양한 목적으로 사용될 수 있다.
x86-64 프로세서는 x86 프로세서가 가지는 범용 레지스터 외에도 R8~R15로 이름 붙여진 8개의 레지스터가 더 있다.
이 레지스터의 기능은 다른 범용 레지스터와 같으며 차이점이라면 특수한 용도가 정의되지 않았다는 것이다.

| 범용 레지스터 명 | 용도 |
| :--: | :-- |
| AX | 산순 연산을 수행할 때 누산기로 사용 (Accumulate) |
| BX | 데이터의 어드레스를 지정할 때 데이터 포인터로 사용 (Base) |
| CX | 루프 혹은 문자열의 카운터로 사용 (Count) |
| DX | I/O Address 지정할 때 사용, 산술 연산을 수행할 때 보조 레지스터 (Data) |
| SI | 문자열을 작업 진행 시 원본 문자열의 인덱스 (Source Index) |
| DI | 문자열을 작업 진행 시 목적 문자열의 인덱스 (Destination Index) |
| SP | 스택의 포인터로 사용 (Stack Pointer) |
| BP | 스택의 데이터에 접근할 때 데이터의 포인터로 사용 (Base Pointer) |
| R8~R15 | x86-64 프로세서에 추가된 범용 레지스터로, 다양한 용도로 사용 |

레지스터가 특수한 용도로 사용되는 예로 PC에 연결된 디바이스를 제어하려면 장치가 연결된 I/O 어드레스에 접근해야 한다.
이때 I/O어드레스를 저장할 수 있는 레지스터는 DX를 통해서만 가능하다.
또 다른 예는 정수 곱셈 코드에서 찾을 수 있다.
곱셈 명령은 오퍼랜드가 하나밖에 없는데 이것이 가능한 이유는 곱셈 명령이 다른 하나의 오퍼랜드로 AX레지스터를 사요하기 때문이다.
곱셈 명령은 AX와 오퍼랜드를 곱한 후, 그 결과를 DX:AX, 혹은 AX에 저장하도록 설계되어있다.

64비트 범용 레지스터는 하위 32비트, 16비트, 8비트의 크기로 구분하여 접근할 수 있고, 레지스터에 접두사(Prefix)나 접미사(Postfix)를 붙여 접근하는 크기를 표시한다.
대체로 64비트 레지스터에는 RAX, RBX처럼 R 접두사가 붙고, 32비트 레지스터에는 EAX, EBX, E8D, R9D처럼 E접두사나 D접미사가 붙는다.
16비트 레지스터는 AX, BX, R8W, R9W처럼 접두사가 붙지 않거나 W접미사가 붙는다.
16비트 이하의 레지스터는 상위 8비트와 하위 8비트로 다시 구분되는데 상위 8비트는 AH, BH처럼 끝자리가 H로 변경되고, 하위 8비트는 AL, BL, SIL, DIL, R8L, R9L처럼 끝자리가 L로 변경되거나 접미사 L이 붙는다.

리얼 모드에서 16비트 크기 이하의 레지스터만 접근 가능한 것으로 되어 있지만, 오퍼랜드 크기 접두사(Operand-Size Prefix, 0x66)를 사용하거나 어드레스 크기 접두사(Address-Size Prefix, 0x67)를 사용하면 32비트 레지스터도 접근할 수 있지만, 이런 경우는 보호 모드로 전환하는 것처럼 특수한 상황이므로 리얼 모드에서 16비트 이하의 크기를 가지는 레지스터에만 접근한다고 생각해도 된다.
운영 모드에 따라 접두사를 결합하는 방법에는 일정한 규칙이 있으며 사용한 접두사에 따라 명령어(Instruction)가 처리하는 오퍼랜드나 어드레스의 크기에 따라 달라진다. 아래 표는 운영 모드와 접두사에 따라 오퍼랜드와 어드레스의 크기가 어떻게 변화하는지 나타낸 것이다.

|     | 리얼 모드 | 보호 모드 | IA-32e 모드(64비트 서브모드) |
| :-: | :-------: | :-------: | :--------------------------: |
| REX 접두사<br/>- IA-32e 모드 전용 | X  X  X  X | X  X  X  X | N  N  N  N   Y  Y  Y  Y |
| 오퍼랜드 크기 접두사 | N  N  Y  Y | N  N  Y  Y | N  N  Y  Y   N  N  Y  Y |
| 어드레스 크기 접두사 | N  Y  N  Y | N  Y  N  Y | N  Y  N  Y   N  Y  N  Y |
| 유효한 오퍼랜드 크기 | 16 16 32 32 | 32 32 16 16 | 32 32 16 16  64 64 64 64 |
| 유효한 어드레스 크기 | 16 32 16 32 | 32 16 32 16 | 64 32 64 32  64 32 64 32 |

위 표를 보면 IA-32e 모드의 기본 오퍼랜드 크기가 32비트로 표시된 것을 볼 수 있다.
어떤 이유에서인지는 모르겠지만 IA-32e 모드의 기본 오퍼랜드 크기는 32비트, 기본 어드레스 크기는 64비트로 설계되어 있다.
그리고 오퍼랜드가 32비트로 설계되어 어드레스를 포현할 수 없으므로 RIP 상대 어드레스라는 새로운 어드레스 계산 방식이 도입되었다.

RIP 레지스터는 현재 수행중인 명령의 어드레스를 가리키는 레지스터이다.
이름에서 알 수 있듯이 크기가 64비트이다. RIP 레지스터의 값과 32비트 오퍼랜드를 토해 64비트 주소 공간을 나타낼 수 있으며, 이것이 RIP 상대 어드레스 방시그이 어드레스 지정방법이다. 하지만 기본 오퍼랜드의 크기가 32비트이므로 RIP 레지스터의 값에 상위 2GB와 하위 2GB 범위까지만 표현할 수 있는 단점이 있다.
그래서 프로세서 제조사에서는 이런 경우를 대비하여 무조건 분기 명령어(jmp)에 예외를 두었다.
즉, 무조건 분기 명령어의 오퍼랜드의 크기는 기본 64비트로 하여 전체 어드레스 범위에서 이동이 가능하도록 한 것이다.
아래 그림은 RIP 상대 어드레스를 사용하여 표현 가능한 어드레스 영역과 무조건 분기 명령어를 사용해서 접근할 수 있는 영역에 대해 나타낸 것이다.

![](https://github.com/HIPERCUBE/64bit-Multicore-OS/blob/master/book/img/Ch3_img4.png)


### 세그먼트 레지스터
세그먼트 레지스터(Segment Register)는 16비트 레지스터로 어드레스 영역을 다양한 크기로 구분하는 역할을 한다.
세그먼트 레지스터의 주된 역할은 어드레스 영역의 구분이지만, 모드마다 조금씩 차이가 있다.
리얼 모드에서는 단순히 고정된 크기의 어드레스 영역을 지정하는 역할만 하지만, 보호 모드와 IA-32e 모드에서는 접근권한(Privilege Level), 세그먼트의 시작 어드레스와 크기 등을 지정하는데 사용되기도 한다.
이러한 기능을 이용하면 응용프로그램으로부터 커널 영역을 보호하는 기능을 쉽게 구현할 수 있다.

세그먼트 레지스터는 CS, DS, SS, ES, FS, GS 총 6개로 구성된다.

| 세그먼트 레지스터 이름 | 설명 |
| :--: | :-- |
| CS | 코드 영역을 가리키는 레지스터<br/>데이터 이동 명령으로 값을 변경할 수 없으며 점프 명령이나 인터럼트 과련 명령으로 변경 가능 |
| DS, ES, FS, GS | 데이터 영역을 가리키는 레지스터<br/>데이터 이동명령으로 값을 변경할 수 있음<br/>DS 레지스터는 데이터 영역에 접근할 때 암시적으로 사용됨<br/>데이터 영역에 접근하면서 DS레지스터 이외의 세그먼트 레지스터를 사용하려면 세그먼트 레지스터 접두사 사용 |
| SS | 스택 영역을 가리키는 레지스터<br/>데이터 이동 명령으로 값을 변경할 수 있음<br/>스택 관련 레지스터(SP, BP)를 통해 스택에 접근할 때 암시적으로 사용된다. |

세그먼트 레지스터에는 DS, ES, FS, GS 와 같이 총 4개의 데이터 관련 세그먼트 레지스터가 있으며, 세그먼트 레지스터 접두사를 통해 명시적으로 특정 세그먼트를 설정할 수 있다.
명시적으로 지정하지 않으면 기본적으로 사용되는 세그먼트 레지스터는 위 표에서 보는것과 같다.

세그먼트 레지스터의 역할은 주소 공간을 목적에 따라 구분하는 것이며, 주소 공간을 구분하는 방법은 메모리 관리 기법과 깊은 관계가 있다. 메모리 관리 기법에는 크게 세그멘테이션 기법, 페이징 기법 두 가지가 있다.
이중에서 세그먼트 레지스터를 통해 주소 공간을 구분하는 방식이 세그멘테이션이다.

### 컨트롤 레지스터
컨트롤 레지스터(Control Register)는 운영모드를 변경하고, 현재 운영중인 모드의 특정 기능을 제어하는 레지스터이다.
x86 프로세서에서는 CR0, CR1, CR2, CR3, CR4의 5개의 컨트롤 레지스터가 존재하며, x86-64프로세서에는 CR8이 추가되어 총 6개의 컨트롤 레지스터가 있다.

| 컨트로 레지스터 | 설명 |
| :--: | :-- |
| CR0 | 운영 모드를 제어하는 레지스터<br/>리얼 모드에서 보호 모드로 전환하는 역할과 캐시, 페이징 기능 등을 활성시킨다. |
| CR1 | 프로세서에 의해 예약된 레지스터 |
| CR2 | 페이지 폴트 발생 시 페이지 폴트가 발생한 선형 주소가 저장되는 레지스터<br/>페이징 기법을 활성화한 후에는 페이지 폴트 발생 시만 유효한 값을 가진다. |
| CR3 | 페이지 디렉터리의 물리 주소와 페이 ㅣ 캐시에 관련된 기능을 설정하는 레지스터 |
| CR4 | 프로세서에서 지원하는 각종 확장 기능을 제어하는 레지스터<br/>페이지 크기 확장이나 메모리 영역 확장 등의 기능을 활성시킨다. |
| CR8 | 태스크 우선순위 레지스터의 값을 제어하는 레지스터<br/>프로세스 외부에서 발생하는 인터럽트를 걸러주는 필터의 역활<br/>IA-32e 모드에서만 접근 가능 |

컨트롤 레지스터는 리얼 모드와 보호 모드일 때 32비트 크기이며, IA-32e 모드에서는 64비트로 확장되지만 일부 제약사항이 있다.
CR0, CR4, CR8 레지스터에서는 64비트 중 상위 32비트를 0으로 설정해야 한다.
CR2레지스터의 경우는 64비트 영역을 모두 사용할 수 있으며, CR3 레지스터는 비트 40부터 비트 51까지 모두 0으로 설정해야한다.

컨트롤 레지스터는 프로세스의 운영 모드와 확장 기능를 제어하는 레지스터인 만큼 아래 그림처럼 구조가 복잡하다.
각 필드는 저마다 특정 기능을 활성/비활성화하며, 현재 운영 모드에 따라 필수 필드와 옵션 필드가 달라진다.
컨트롤 레지스터의 특정 기능은 해당 비트를 1로 설정해도 충분하지만, 특정 기능은 1로 설정하기 전에 프로세서가 사용할 자료구조를 미리 준비해야 한다.
조건을 충족하지 못했다면 시스템은 재부팅되거나 먹통이 되곤 한다.

![](https://github.com/HIPERCUBE/64bit-Multicore-OS/blob/master/book/img/Ch3_img5.png)

지금까지 x86-64 프로세서의 운영 모드와 레지스터를 중심으로 살펴보았다.
이 부분을 OS를 만들 때 곡 알아둬야 하는 부분이며, 각 필드에 대해 세세하게 알 필요는 없지만 적어도 세그먼트 레지스터와 컨트롤 레지스터들이 어떤 역활을 하고 어떤 용도로 사용되는지 알아야 한다.

## 운영 모드와 메모리 관리 기법
x86과 x86-64 프로세서에서 지원하는 메모리 관리 기법은 크게 두 가지가 있다.
한 가지는 세그멘테이션(Segmentation)이고, 다른 한 가지는 페이징(Paging)이다.
세그멘테이션과 페이징은 주소 공간을 특정 영역으로 나눈다는 공통점이 있지만, 나누는 방식에 차이가 있다.
세그멘테이션은 전체 영역을 원하는 크기로 나누어 관리하는 방식이고, 페이징은 일정한 단위로 잘라서 조각을 모아 원하는 크기로 관리하는 방식이다.
메모리 관리 기법을 사용하려면 과련 레지스터에 특정한 자료구조를 설정해야 한다.
세그멘테이션은 세그먼트 레지스터에 세그먼트의 시작 주소 혹은 디스크립터(Descriptor)라고 불리는 자료구조의 위치를 설정해야 한다.
페이징은 컨트롤 레지스터 중에 CR3 레지스터에 페이지 디렉터리라고 불리는 자료구조의 물리 주소를 설정해야 사용이 가능하다.
그리고 모든 운영모드가 세그먼트와 페이징을 지원하는 것은 아니고 모드에 따라 지원하지 않거나 지원하지만 일부 기능이 제한되는 경우도 있다.
이러한 차이는 x86-64 프로세서가 기존 프로세서와 호환성을 유지하면서 발전했기 때문이다.


### 리얼 모드의 메모리 관리 방식
리얼모드는 최대 1MB의 주소공간을 사용하며 세그멘테이션만 지원한다.
리얼모드에서 세그먼트 크기는 64kb로 고정이고, 세그먼트의 시작 어드레스는 세그먼트 레지스터에 직접 설정한다.
세그멘테이션에서 세그먼트의 시작 어드레스는 코드나 메모리에 접근할 때 기준 어드레스(Base Address)로 사용된다.
아래 그림은 리얼 모드의 세그먼트 레지스터와 세그먼트, 물리 주소의 관계를 나타냈다.

![](https://github.com/HIPERCUBE/64bit-Multicore-OS/blob/master/book/img/Ch3_img6.png)

리얼 모드는 페이징을 사용하지 않으므로 물리 주소가 변환하는 방식이 비교적 간단하다.
세그멘테이션을 거쳐 나온 어드레스가 바로 물리 주소다.
리얼모드의 세그멘테이션은 세그먼트 레지스터의 값에 범용 레지스터의 값을 더하는 방식으로 동작한다.
여기서 세그먼트 레지스터의 값을 그대로 ㅓㅂㅁ용 레지스터에 더하는 것이 아니라, 세그먼트 레지스터의 값에 16을 곱한 값을 세그먼트의 기준 주소로 사용하는 것이다.
16비트의 최댓값은 65536이며, 여기에 16을 곱하면 세그먼트의 주소는 거의 1MB에 근접하는 1048560가 된다.
이값에 범용 레지스터를 더한 값이 실제 물리 주소가 되므로 1MB까지 접근할 수 있다.
아래 그림은 세그먼트 레지스터에 0x1000, 범용 레지스터에 0x1324가 설정되었을때 물리 주소를 계산하는 방법을 나타낸 것이다.

![](https://github.com/HIPERCUBE/64bit-Multicore-OS/blob/master/book/img/Ch3_img7.png)

리얼 모드의 이러한 세그멘테이션 기법은 보호 모드에도 영향을 주었다.
보호 모드 역시 같은 방시긍로 세그먼트의 기준 주소에 범용 레지스터를 더해 계산한다.
다만, 페이징이 추가되어서 계산 결과는 물리 주소가 아인 선형 주소라고 불리는 논리 주소로 바뀌었고, 선형 주소는 페이징을 거쳐 물리 주소로 바뀌게 된다.

### 보호 모드의 메모리 관리 방식
보호 모드는 리얼 모드와 달리 세그멘테이션과 페이징을 모두 지원한다.
보호모드의 세그멘테이션은 리얼모드의 세그멘테이션보다 많은 기능을 제공한다.
또한 보호 모드의 세그멘테이션은 세그먼트 레지스터에 세그먼트 기준 주소를 직접 설정하는 대신 디스크립터 자료구조의 위치(Offset)을 성정하는 방식으로 바뀌었다.
세그먼트 레지스터의 명칭도 세그먼트 디스크립터를 선택한다는 의미에서 세그먼트 셀렉터로 바뀌었다.

디스크립터는 메모리 영역의 정보를 저장하는 자료구조로 여러 종류가 있으며, 그 중에서 세그먼트에 대한 정보를 나타내는 디스크립터를 세그먼트 디스크립터라고 부른다.
세그먼트 디스크립터에는 세그먼트의 시작 어드레스와 크기, 권한(Privilege), 타입(Type) 등의 정보가 있다.

![](https://github.com/HIPERCUBE/64bit-Multicore-OS/blob/master/book/img/Ch3_img8.png)

세그먼트 디스크립터에 포함된 특권 레벨(DPL, Descriptor Privilege Level)은 해당 세그먼트에 접근하기 위한 최소한의 권한을 나타내고, 특권레벨은 0~3 사이의 값을 가지며, 숫자가 작을수록 권한이 높다.

세그먼트에 접근하려면 현재 수행 중인 특권 레벨(CPL, Current Privillege Level)이 적어도 디스크립터에 설정된 권한과 같거나 높아야(숫자가 작아야) 한다.
조건을 만족하지 않으면 프로세서는 예외를 발생시켜 문제가 발생했음을 알린다.
접근하는 어드레스가 세그먼트의 크기를 넘어서는 경우도 역시 예외가 발생한다.

보호 모드에서 세그먼트 레지스터는 세그먼트 디스크립터의 위치를 가리킨다.
세그먼트 디스크립터는 메모리상에 위치하는 자료구조의 일종으로 GDT(Global Descriptor Table)라고 불리는 곳에 모여 있다.
GDT는 연속된 디스크립터의 집합이며, 최대 8192개의 디스크립터를 포함할 수 있는 테이블 형태의 자료구조이다.
GDT의 위치는 GDTR(Global Descriptor Table Register)에 저장되어 있으며 16비트 GDT크기 필드와 32비트 기준 주소 필드로 구성된 자료구조의 물리 주소를 넘겨 받는다.

보호 모드에서 주소를 계산하는 방법은 리얼모드와 마찬가지로 세그먼트 레지스터의 기준 주소에 범용 레지스터의 값을 더해서 구한다.
이렇게 계산한 결과가 선형 주소이며 프로세서는 이 선형 주소로 실제 물리 주소에 접근한다.
보호 모드는 리얼 모드와 달리 세그먼트의 크기를 지정할 수 있다.
세그먼트 크기는 해당 세그먼트의 어드레스에 접근할 때 참조하며, 기준 주소에 더해질 값은 세그먼트의 크기를 넘을 수 없으며 이를 위반하며 예외가 발생한다.
아래 그림은 세그먼트 레지스터와 세그먼트 디스크립터, 선형 주소의 관계이다.

![](https://github.com/HIPERCUBE/64bit-Multicore-OS/blob/master/book/img/Ch3_img9.png)

선형 주소는 이후에 나올 페이징의 입력 값이 되며, 페이징을 사용하지 않는다면 선형 주소는 물리 주소와 1:1로 대응하며 메모리 구조는 최대한 간단하게 유지하는 편이 좋다.
아래 그림은 이러한 세그멘테이션과 페이징을 통해 논리 주소를 물리 주소로 변환하는 과정이다.

![](https://github.com/HIPERCUBE/64bit-Multicore-OS/blob/master/book/img/Ch3_img10.png)

페이징은 물리 메모리를 페이지(Page)라고 불리는 일정한 크기로 나누고, 선형 주소와 물리 주소를 나눠 놓은 페이지로 연결하는 방식을 말한다.
페이징을 사용하면 큰 영역의 선형 주소도 물리 페이지만 연결하면 사용이 가능하므로, 주소 공간을 더 넓게 사용할 수 있는 장점이 있다.
또한 같은 물리 페이지를 여러 선형 주소에 연결함으로써 응용 프로그램끼리 공유하는 메모리를 손쉽게 처리할 수 있다.
물론 반대로 각 프로그램마다 독립적인 주소 공간 보장 역시 가능하다.
OS는 페이징의 이러한 기능을 이용하여 응용프로그램에 독립된 주소 공간 보장, 공유 메모리, 요구 페이징 공유 라이브러리등의 기능을 구현할 수 있다.

보호 모드에서 페이징은 페이지 크기에 따라 크게 두 가지 방식으로 구분한다.
하나는 물리 메모리를 4KB로 나누고 선형 주소를 3단계로 구분하는 방식이며, 다른 하나는 물리 메모리를 4MB 크기로 나누고 선형 주소를 2단계로 구분하는 방식이다.
두 방식의 기본 원리는 같으므로 3단계로 구분하는 페이지응로 성명하겠다.
3단계 페이징은 선형 주소를 디렉터리, 테이블, 오프셋 세 부분으로 나누며 물리 메모리를 4KB 페이지로 나누어 관리하는 방식이다.
선형 주소의 디렉터리 부분과 테이블 부분은 각기 페이지 디렉터리와 페이지 테이블에 있는 엔트리의 위치를 나타낸다.
페이지 디렉터리와 테이블은 GDT처럼 메모리 공간에 있는 자료구조일 분이며 CR3 컨트롤 레지스터에 페이지 디렉터리의 시작 주소가 있다.

페이지 디렉터리 엔트리와 페이지 테이블 엔트리는 크기가 모두 4바이트이다.
페이지 크기가 모두 4KB이므로 비트 12 ~ 비트 31로 기준 주소를 나타내고 비트 11 ~ 비트 0은 속성 필드로 사용한다.

![](https://github.com/HIPERCUBE/64bit-Multicore-OS/blob/master/book/img/Ch3_img11.png)

위 그림은 두 가지 엔트리 중에서 페이지 테이블 엔트리이다.
페이지 디렉터ㅣㄹ 엔트리 역시 하위 12비트가 속성 필드로 할당되어 있으며, 몇몇 필드를 제외하면 페이지 테이블 엔트리와 거의 같다.
속성 필드 중에 유심히 봐야 할 필드는 U/S (User/Supervisor) 필드이다.
U/S필드는 해당 페이지에 접근할 수 있는 권한을 나타낸다.
0으로 설정하며 유저 어플리케이션을 제외한 모든 레벨에서 접근이 가능하고 1로 설정하면 모드 레벨에서 접근 가능하다.
그리고 페이지 보호 기능과 세그멘테이션의 보호 기능을 조합하면 메모리 모델을 단순하게 유지하면서 커널 영역과 유저 영역을 구분하느것이 가능하다.

선형 주소는 최상위 비트부터 디렉터리 오프셋 10비트, 테이블 오프셋 10비트, 테이지 오프셋 12비트로 구분한다.
디렉터리와 테이블의 오프셋이 10비트이므로 페이지 디렉터리와 테이블의 엔트리 수는 총 1024개이다.
선형 주소의 마지막에 있는 페이지 오프셋은 12비트이므로 최댓값은 4KB이며, 12비트인 이유는 4KB 페이지의 오프셋에 나타내기 때문이다.
페이지 디렉터리 엔트리와 페이지 테이블 엔트리 값은 각자 다음에 위치하는 페이지 테이블의 시작 주소와 페이지의 시작 주소를 나타내며 이 값에 선형 주소의 오프셋을 더해 물리 주소를 구한다.
아래 그림은 3단계 페이징 어드레스 변환 과정이다.

![](https://github.com/HIPERCUBE/64bit-Multicore-OS/blob/master/book/img/Ch3_img12.png)

위 그림을 바탕으로 선형 주소에서 물리 주소로 구하는 과정을 간단히 정리해보면 다음과 같다.
 > 1. CR3 레지스터에 설정된 어드레스로 페이지 디렉터리의 시작주소를 찾는다
 > 2. 페이지 디렉터리의 시작 주소에 선형 주소의 디렉터리 오프셋을 이용해서 해당 디렉터리 엔트리를 찾는다. (디렉터리 엔트리에 설정된 값이 페이지 테이블의 시작 주소)
 > 3. 페이지 테이블의 시작 주소에 선형 주소의 테이블 오프셋을 이용해서 해당 페이지 테이블 엔트리를 찾는다. (페이지 테이블 엔트리에 설정된 값이 4KB 페이지의 시작 주소)
 > 4. 페이지의 시작 주소에 선형 주소의 페이지 오프셋 값을 더해 실제 물리 주소로 변환한다.


### IA-32e 모드의 메모리 관리
IA-32e모드는 두 가지 서브모드가 있는데 그 중 호환모드는 보호 모드와 동작이 같으므로 생략하고 64비트 모드만 설명한다.
IA-32e 모드는 보호 모드보다 1,000,000,000배 이상의 공간을 자랑하지만 메모리 관리 기법은 보호 모드와 기본적인 부분은 거의 같다.
따라서 IA-32e 모드는 보호 모드와 차이점을 중심으로 설명한다.
IA-32e 모드의 세그멘테이션은 보호 모드의 세그멘테이션과 큰 차이가 없고 몇 가지 기능이 추가되면서 약간의 차이가 생겼을 뿐이다.

한 가지 차이점은 세그먼트 디스크립터에 설정된 기준 주소와 크기에 관계없이 모든 세그먼트가 기준 주소는 0, 크기는 64비트 전체로 설정된다는 것이다.
이는 보호 모드에서 사용하던 세그먼트 디스크립터가 32비트 어드레스만 저장하게 설계된 탓이며, 64비트 어드레스 지원을 위해 디스크립터를 확장하지 않고 강제로 값을 고정함으로써 이를 해결했다.
따라서 IA-32e 모드에서는 선형 주소를 기준 주소가 다른 여러 개의 세그먼트로 구분할 수 없음을 고려해서 OS를 설계해야 한다.

다른 차이점은 IA-32e 모드는 호환모드와 64비트 모드의 두 가지 서브모드를 지원하므로 이를 구분하고자 코드 세그먼트 디스크립터에 L필드(비트21)가 추가된 것이다.
이 필드를 9으로 설정하면 호환 모드로 동작하며 1로 설정하면 64비트 모드로 동작하므로 IA-32e모드에서는 굳이 보호 모드로 돌아가지 않고도 32비트 코드를 실행할 수 있다.
아래 그림은 IA-32e모드의 64비트 모드에서 세그먼트 셀렉터, 세그먼트 디스크립터, 선형 주소의 관계를 나타낸것이다.

![](https://github.com/HIPERCUBE/64bit-Multicore-OS/blob/master/book/img/Ch3_img13.png)

IA-32e모드의 페이징은 보호 모드와 달리 주소 공간이 64비트로 늘어나므로 PAE 기능이 기본으로 활성화 된다.
또한 어드레스가 늘어난 만큼 변환 단계도 늘어서 4KB 페이지는 5단계로, 2MB 페이지는 4단계로 변경된다.
그로 인해 새롭게 추가된 테이블은 페이지 맵 레벨 4 테이블(PML4, Page Map Level 4 Table)과 페이지 디렉터리 포이넡 테이블(PDPT, Page Directory Pointer Table)이며, 변환 과정은 앞서 설명했던 다른 테이블과 같다.
보호 모드에서 4KB 페이지의 3단계 방식에 대해 살펴봤으니 이번에는 비교를 위해 4KB 페이지를 가지는 5단계 방식에 대해 알아보겠다.
아래 그림은 4KB 페이지의 5단계 방식이다.

![](https://github.com/HIPERCUBE/64bit-Multicore-OS/blob/master/book/img/Ch3_img14.png)

위 그림에서 보는 바와 같이 보호 모드에서 단계만 더 늘어났을 뿐 변환 과정은 거의 같다.
차이점이라면 각 테이블의 인덱스가 9비트로 줄어들어 엔트리의 개수가 512개로 줄어든 정도이다.
그런데 위 그림을 유심히 보면 선형 주소가 2^64까지 표현할 수 있음에도 불구하고, 비트 48 ~ 비트 63까지 부호 확장으로 채워진다는 것을 알 수 있다.
다시 말하면 64비트 선형 주소 중에 실제로 변환에 사용되는 부분은 48비트까지이며, 최대로 표현 가능한 어드레스 범위가 128TB까지라는 말이다.
여기서 물리 주소로 변환할 수 있는 능력은 각 프로세서에 따라 다르며 프로세서가 40비트의 물리 주소를 지원하는 경우에만 최대 1TB의 물리 메모리를 사용할 수 있다.
이는 아래 그림을 보면 더욱 명확하게 알 수 있다.

![](https://github.com/HIPERCUBE/64bit-Multicore-OS/blob/master/book/img/Ch3_img15.png)

위 그림은 IA-32e모드의 페이지 테이블 엔트리를 나타낸 것이며 비트 40에서 비트 51까지 모두 0으로 예약된 것을 확인할 수 있다.

IA-32e 모드의 페이지 엔트리는 64비트로 늘어난 어드레스로 인해 8바이트 늘어났다.
하위 4바이트는 보호 모드와 구조가 같고 상위 4바이트는 기준 주소 필드와 예약된 영역, 임의로 사용 가능한 영역, EXB로 구성된다.
이중에서 EXB 필드는 해당 페이지에서 명령어가 실행되는 것을 막는 필드이다.
